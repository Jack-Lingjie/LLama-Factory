import json
from concurrent.futures import ThreadPoolExecutor, as_completed  
import os
import pandas as pd
from gpt4o import Openai, API_INFOS
from datasets import load_dataset, Dataset
from tqdm import tqdm

system_template = \
"""You are tasked with acting as a text rewriter to enhance the aesthetic quality of text generated by a Large Language Model (LLM). Your job is to evaluate the provided user instruction and the LLM-generated response from an aesthetic perspective, determine whether the text needs modification, and then provide the revised text if necessary.  
  
The goal is to ensure that the text, when rendered in Markdown or HTML, is visually appealing and easy to read and understand. These modifications should be reasonable and appropriate, rather than mandatory, and you may adjust or omit specific requirements as necessary.  
  
## Format  
  
**Textual Aesthetic Analysis:**  
Your analysis 
  
**Does it need modification:**  
If need modification: [[Y]] 
If donn't need modification: [[N]]  

  
**Revised Text:**  
[Your revised text, if applicable]  
  
## Textual Aesthetic Elements to Consider:  
  
1. **Paragraph Structure**: Ensure paragraphs are of appropriate length and logically structured. Use appropriate spacing between paragraphs to avoid dense text.  
2. **Indentation**: Apply consistent indentation where necessary.  
3. **Headings and Subheadings**: Use Markdown headings (`#`, `##`, `###`, etc.) to organize content and improve readability.  
4. **Lists and Bullet Points**: Utilize lists (ordered and unordered) to break down complex information.  
   - For unordered lists, use `-`, `*`, or `+`.  
   - For ordered lists, use `1.`, `2.`, `3.`, etc.  
5. **Markdown Formatting**: Apply Markdown for bold (`**bold**`), italic (`*italic*`), and code blocks (`` `code` `` or triple backticks for code blocks) to highlight important information or distinguish between different types of text.  
6. **Line Spacing**: Adjust line spacing to enhance readability. Use empty lines to separate sections.  
7. **Consistency**: Maintain a consistent style throughout the document.  
8. **Visual Breaks**: Use visual breaks (`---` or `***`) to separate different sections and improve flow.  
9. **Emphasis and Bold**: Use bold (`**bold**`) and italic (`*italic*`) text to emphasize important points.  
10. **Blockquotes**: Use blockquotes (`>`) for quotations or highlighted text.  
11. **Links**: Format hyperlinks using `[text](URL)`.  
12. **Tables**: Use Markdown tables for any tabular data.  
13. **Task Lists**: For task lists, use `- [ ]` for incomplete tasks and `- [x]` for completed tasks.  
14. **Footnotes**: Use footnotes (`[^1]`) and provide the footnote content at the end of the document.  
15. **Code and Inline Code**: Use code blocks for larger code sections and inline code for shorter segments.  
16. **Whitespace and Spacing**: Ensure appropriate use of whitespace and spacing to avoid a cluttered appearance.  
  
These elements will ensure that the revised text is aesthetically pleasing, easy to read, and well-structured when rendered in Markdown.  
"""

user_template = \
"""### User Instruction:  
{instruction}  
  
### Answer:  
{completion}  
  
Your task is to:  
  
1. Analyze the LLM-generated response from a textual aesthetic perspective.  
2. Determine whether the text needs modification.  
3. Provide a revised version of the text if necessary.  
  
*Format*   
  
**Textual Aesthetic Analysis:**  
[Your analysis]  
  
**Does it need modification:**  
If need modification: [[Y]]  
If don't need modification: [[N]]  
  
**Revised Text:**  
If need modification: [Your revised text]  
If don't need modification: [""]  
  
*Textual Aesthetic Elements to Consider*:  
  
1. **Paragraph Structure**: Ensure paragraphs are of appropriate length and logically structured. Use appropriate spacing between paragraphs to avoid dense text.  
2. **Indentation**: Apply consistent indentation where necessary.  
3. **Headings and Subheadings**: Use Markdown headings (`#`, `##`, `###`, etc.) to organize content and improve readability.  
4. **Lists and Bullet Points**: Utilize lists (ordered and unordered) to break down complex information.  
   - For unordered lists, use `-`, `*`, or `+`.  
   - For ordered lists, use `1.`, `2.`, `3.`, etc.  
5. **Markdown Formatting**: Apply Markdown for bold (`**bold**`), italic (`*italic*`), and code blocks (`` `code` `` or triple backticks for code blocks) to highlight important information or distinguish between different types of text.  
6. **Line Spacing**: Adjust line spacing to enhance readability. Use empty lines to separate sections.  
7. **Consistency**: Maintain a consistent style throughout the document.  
8. **Visual Breaks**: Use visual breaks (`---` or `***`) to separate different sections and improve flow.  
9. **Emphasis and Bold**: Use bold (`**bold**`) and italic (`*italic*`) text to emphasize important points.  
10. **Blockquotes**: Use blockquotes (`>`) for quotations or highlighted text.  
11. **Links**: Format hyperlinks using `[text](URL)`.  
12. **Tables**: Use Markdown tables for any tabular data.  
13. **Task Lists**: For task lists, use `- [ ]` for incomplete tasks and `- [x]` for completed tasks.  
14. **Footnotes**: Use footnotes (`[^1]`) and provide the footnote content at the end of the document.  
15. **Code and Inline Code**: Use code blocks for larger code sections and inline code for shorter segments.  
16. **Whitespace and Spacing**: Ensure appropriate use of whitespace and spacing to avoid a cluttered appearance.  
""" 

def get_data():
    ds = load_dataset("HuggingFaceH4/ultrafeedback_binarized", split="train_prefs")
    def get_instruct_response(item):
        # item["instruction"] = item['chosen'][0]["content"]
        item["response"] = item['chosen'][1]["content"]
        return item
    ds = ds.map(get_instruct_response, batch_size=1024, num_proc=8)
    export_data = ds.select_columns(["prompt", "response"])
    return export_data

def get_revised_text(client, instruction, completion, user_template, system_template, max_tokens=2048):  
    # Format the user template with the given instruction and completion  
    content = user_template.format(instruction=instruction, completion=completion)  
    # Get the response from the client  
    gpt_answer = client.get_response(content=content, system=system_template, max_tokens=max_tokens)  
    gpt_answer = gpt_answer.strip()  
  
    # Determine if modification is needed  
    need_modification = "Y" if "If need modification: [[Y]]" in gpt_answer else "N"  
      
    # Extract the revised text if modification is needed  
    if need_modification == "Y":  
        revised_text_start = gpt_answer.find("If need modification: [") + len("If need modification: [")  
        revised_text_end = gpt_answer.find("]", revised_text_start)  
        revised_text = gpt_answer[revised_text_start:revised_text_end].strip()  
    else:  
        revised_text = ""  
  
    return need_modification, revised_text, gpt_answer  
 
  
def process_row(index, client, row, user_template, system_template, max_tokens=2048, output_file="output.jsonl"):  
    prompt = row['prompt']  
    response = row['response']  
    need_modification, revised_text, gpt_answer = get_revised_text(client, prompt, response, user_template, system_template, max_tokens=max_tokens)  
    # print(f"index {index}")
    result = {  
        'index': index,  
        'prompt': prompt,  
        'response': response,  
        'does_it_need_modification': need_modification,  
        'revised_text': revised_text,  
        'gpt_answer': gpt_answer  
    }  
    # Write the result to a JSONL file  
    with open(output_file, 'a') as f:  
        f.write(json.dumps(result) + "\n")  
    return result  
def main():  
    # Initialize multiple clients  
    clients = [Openai(apis=[API_INFOS[i]]) for i in range(6)]  
    export_data = get_data()
    sample_data = export_data.select(range(100))
    # user_template = "User: {instruction}\nCompletion: {completion}"  
    # system_template = "You are a helpful assistant."  
    max_tokens = 2048  
    output_file = "data_process/revised_data/output.jsonl"  
  
    # Clear the output file before starting  
    if os.path.exists(output_file):  
        os.remove(output_file)  
  
    revised_data = []  
  
    with ThreadPoolExecutor(max_workers=6) as executor:  
        # Create a future for each row in the dataset  
        futures = [executor.submit(process_row, i, clients[i % len(clients)], row, user_template, system_template, max_tokens, output_file) for i, row in enumerate(sample_data)]  
  
        # Collect the results as they complete  
        for future in tqdm(as_completed(futures), total=len(futures)):  
            revised_data.append(future.result())  
        # with tqdm(total=len(futures)) as pbar:  
        #     # Collect the results as they complete  
        #     for future in as_completed(futures):  
        #         result = future.result()  
        #         revised_data.append(result)  
        #         pbar.update(1)  # Update the progress bar
  
    # Load results from JSONL file and ensure the order is preserved  
    with open(output_file, 'r') as f:  
        revised_data = [json.loads(line) for line in f]  
  
    # Sort by the original index  
    revised_dataset = revised_data.sort(key=lambda x: x['index'])  
  
    # Create a new Dataset  
    revised_dataset = Dataset.from_pandas(pd.DataFrame(revised_data))  
    revised_dataset.to_json("data_process/revised_data/output_sorted.jsonl") 
if __name__ == "__main__":
    main()